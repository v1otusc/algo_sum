## 数学问题

<!-- TOC -->

- [数学问题](#数学问题)
  - [公倍数与公因数](#公倍数与公因数)
  - [质数](#质数)
  - [C++ 中使用随机数](#c-中使用随机数)
  - [蓄水池算法](#蓄水池算法)

<!-- /TOC -->

### 公倍数与公因数

利用辗转相除法,我们可以很方便地求得两个数的最大公因数(greatest common divisor, gcd);将两个数相乘再除以最大公因数即可得到最小公倍数(least common multiple, lcm)。

```c++
int gcd(int a, int b) {
  return b == 0 ? a : gcd(b, a % b);
}
int lcm(int a, int b) {
  return a * b / gcd(a, b);
}
```

进一步地，,我们也可以通过扩展欧几里得算法(extended gcd)在求得 a 和 b 最大公因数的同时,也得到它们的系数 x 和 y,从而使 ax + by = gcd(a, b)。

```c++
int xGCD(int a, int b, int &x, int &y) {
  if (!b) {
    x = 1, y = 0;
  }
  int x1, y1, gcd = xGCD(b, a%b, x1, y1);
  x = x1, y = x1 - (a / b) * y1;
  return gcd;
}
```

### 质数

质数又称素数,指的是指在大于 1 的自然数中,除了 1 和它本身以外不再有其他因数的自然数。**值得注意的是,每一个数都可以分解成质数的乘积，并且最小的质数是 2。**

埃拉托斯特尼筛法(Sieve of Eratosthenes,简称埃氏筛法)是非常常用的,判断一个整数是否是质数的方法。其原理也十分易懂:从 1 到 n 遍历,假设当前遍历到 m,则把所有小于 n 的、且是 m 的倍数的整数标为和数;遍历完成后,没有被标为和数的数字即为质数。


### C++ 中使用随机数



### 蓄水池算法

给定一个数据流，数据流长度 N 很大，且 N 直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。

这个场景强调了 3 件事：

1. 数据流长度N很大且不可知，所以不能一次性存入内存。
2. 时间复杂度为O(N)。
3. 随机选取m个数，每个数被选中的概率为 m/N。

算法思路大致如下：

1. 如果接收的数据量小于m，则依次放入蓄水池；
2. 当接收到第i个数据时，i >= m，在\[0, i\]范围内取以随机数d，若d的落在[0, m-1]范围内，则用接收到的第i个数据替换蓄水池中的第d个数据；
3. 重复步骤2。

下面是该算法的推导验证，假设数据开始编号为1：

第i个接收到的数据最后能够留在蓄水池中的概率=第i个数据进入过蓄水池的概率 x **之后第i个数据不被替换的概率（第i+1到第N次处理数据都不会被替换）。**

1. 当i<=m时，数据直接放进蓄水池，所以第i个数据进入过蓄水池的概率=1。
2. 当i>m时，在\[1,i\]内选取随机数d，如果d<=m，则使用第i个数据替换蓄水池中第d个数据，因此第i个数据进入过蓄水池的概率=m/i。
3. 当i<=m时，程序从接收到第m+1个数据时开始执行替换操作，第m+1次处理会替换池中数据的为m/(m+1)，会替换掉第i个数据的概率为1/m，则第m+1次处理替换掉第i个数据的概率为(m/(m+1))x(1/m)=1/(m+1)，不被替换的概率为1-1/(m+1)=m/(m+1)。依次，第m+2次处理不替换掉第i个数据概率为(m+1)/(m+2)...第N次处理不替换掉第i个数据的概率为(N-1)/N。所以，之后第i个数据不被替换的概率=m/(m+1)x(m+1)/(m+2)...(N-1)/N=m/N。
4. 当i>m时，程序从接收到第i+1个数据时开始有可能替换第i个数据。则参考上述第3点（推理过程一样），之后第i个数据不被替换的概率=i/N。
5. 结合第1点和第3点可知，当i<=m时，第i个接收到的数据最后留在蓄水池中的概率=1xm/N=m/N。结合第2点和第4点可知，当i>m时，第i个接收到的数据留在蓄水池中的概率=m/ixi/N=m/N。综上所述，每个数据最后被选中留在蓄水池中的概率为m/N。

这个算法建立在统计学的基础上，很巧妙地获得了“m/N”这个概率。
