## 位运算

<!-- TOC -->

- [位运算](#位运算)
  - [常用技巧](#常用技巧)
  - [移位运算符](#移位运算符)
    - [左移运算符](#左移运算符)
    - [右移运算符](#右移运算符)
  - [补码计算方法和原理](#补码计算方法和原理)

<!-- /TOC -->

### 常用技巧

常用的位运算符包括 ^ 按位异或(如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。)，& 按位与，| 按位或，~ 取反，<< 算数左移和 >> 算数右移。下面 0s 或 1s 分别表示只由 0 或 1 构成的二进制数字。

```
x ^ 0s = x  x & 0s = 0  x | 0s = x
x ^ 1s = ~x x & 1s = x  x | 1s = 1s
x ^ x = 0   x & x = x   x | x = x
```

异或运算满足交换律和结合律，即 

$$
a \oplus b \oplus a=b \oplus a \oplus a=b \oplus (a \oplus a)=b \oplus0=b
$$

除此之外, n & (n - 1) 可以去除 n 的**位级表示中最低的那一位**，例如对于二进制表示 11110100，,减去 1 得到 11110011,这两个数按位与得到 11110000。n & (-n) 可以得到 n 的位级表示中最低的那一位,例如对于二进制表 11110100,取负得到 00001100,这两个数按位与得到 00000100。

### 移位运算符

移位运算符包括左移 << 和 右移 >>。

#### 左移运算符

**无符号**

语法格式：需要移位的数字 << 移位的次数 n

运算规则：按**二进制形式**把所有数字向左移动相应的位数，高位移出（舍弃），低位的空位补 0。相当于乘以 2 的 n 次方。

例如:4 << 2 ，就是将数字 4 的二进制左移 2 位，具体过程是 4 的二进制形式：00000000 00000000 00000000 00000100；然后把高位2个0移出，其余所有位向左移动2位，低位补0，得到：00000000 00000000 00000000 00010000；十进制数为16，16=4*2<sup>2</sup>

测试程序：

```c++
#include <iostream>
#include <bitset>
using namespace std;
int main() {
  unsigned short short1 = 4;    
  bitset<16> bitset1{short1};   // the bitset representation of 4
  cout << bitset1 << endl;  // 0000000000000100

  unsigned short short2 = short1 << 1;     // 4 left-shifted by 1 = 8
  bitset<16> bitset2{short2};
  cout << bitset2 << endl;  // 0000000000001000

  unsigned short short3 = short1 << 2;     // 4 left-shifted by 2 = 16
  bitset<16> bitset3{short3};
  cout << bitset3 << endl;  // 0000000000010000
}
```

**有符号**

如果左移有符号的数字，以至于符号位受到影响，则结果是不确定的。

#### 右移运算符

**无符号**

语法格式：需要移位的数字 >> 移位的次数 n

运算规则：按二进制形式把所有数字向右移动相应的位数，低位移出（舍弃），高位的空位补 0。相当于除以 2 的 n 次方

例如:4 >> 2 ，就是将数字 4 左移 2 位，具体过程是4的二进制形式：00000000 00000000 00000000 00000100；然后把低位2个0移出，其余所有位向右移动2位，高位补0，得到：00000000 00000000 00000000 00000001；十进制数为1，1=4÷2<sup>2</sup>。

测试代码：

```c++
#include <iostream>
#include <bitset>
using namespace std;

int main() {
  unsigned short short11 = 1024;
  bitset<16> bitset11{short11};
  cout << bitset11 << endl;     // 0000010000000000

  unsigned short short12 = short11 >> 1;  // 512
  bitset<16> bitset12{short12};
  cout << bitset12 << endl;     // 0000001000000000

  unsigned short short13 = short11 >> 10;  // 1
  bitset<16> bitset13{short13};
  cout << bitset13 << endl;     // 0000000000000001

  unsigned short short14 = short11 >> 11;  // 0
  bitset<16> bitset14{short14};
  cout << bitset14 << endl;     // 0000000000000000}
}
```

**有符号**

语法格式：需要移位的数字 >> 移位的次数 n

运算规则：按二进制形式把所有数字向右移动相应的位数，低位移出（舍弃），正数，高位的空位补0。负数，高位的空位补1。

测试代码(正数)：

```c++
#include <iostream>
#include <bitset>
using namespace std;

int main() {
  short short1 = 1024;
  bitset<16> bitset1{short1};
  cout << bitset1 << endl;     // 0000010000000000

  short short2 = short1 >> 1;  // 512
  bitset<16> bitset2{short2};
  cout << bitset2 << endl;     // 0000001000000000

  short short3 = short1 >> 11;  // 0
  bitset<16> bitset3{short3};   
  cout << bitset3 << endl;     // 0000000000000000
}
```

测试代码(负数)：

```c++
#include <iostream>
#include <bitset>
using namespace std;

int main() {
  short neg1 = -16;
  bitset<16> bn1{neg1};
  cout << bn1 << endl;  // 1111111111110000

  short neg2 = neg1 >> 1; // -8
  bitset<16> bn2{neg2};
  cout << bn2 << endl;  // 1111111111111000

  short neg3 = neg1 >> 2; // -4
  bitset<16> bn3{neg3};
  cout << bn3 << endl;  // 1111111111111100

  short neg4 = neg1 >> 4; // -1
  bitset<16> bn4{neg4};    
  cout << bn4 << endl;  // 1111111111111111

  short neg5 = neg1 >> 5; // -1 
  bitset<16> bn5{neg5};    
  cout << bn5 << endl;  // 1111111111111111
}
```

### 补码计算方法和原理

为了区分正负，二进制数用最高位来表示符号，1为负，0为正。用8位二进制数举例，0000 0001=1，1000 0001=-1。

十进制中相反数直接在数字前加负号就可，那么二进制的相反数怎么求呢？不管是十进制还是二进制，相反数的意义都是指：该数+该数的相反数=0。比如 0000 0011 + 它的相反数 = 0000 0000 ，那么 0000 0011的相反数=0000 0000 - 0000 0011 = 1111 1101，直观上理解就是一个数的相反数=对该数按位取反再加1。

下面从理论推导一下：对于某个不为0的二进制数来说，该数+它的相反数=0000 0000，那么该结果一定是由于进位溢出造成的（用二进制相加看，不要用十进制看），相当于1111 1111 + 0000 0001 = 0000 0000，用未溢出的值代替0000 0000，即 该数 + 它的相反数=1111 1111 + 0000 0001，-->  它的相反数 = 1111 1111 - 该数 +0000 0001，1111 1111 - 该数 就相当于对该数按位取反，所以二进制数的相反数就是对其按位取反加1。

我们自己理解的话0000 0011=3，它的相反数为-3=1000 0011（用原码来表示），但0000 0011 + 1000 0011 != 0000 0000,所以计算机就引入了补码，相当于上面的相反数的表示。

将人容易理解的二进制称为原码，计算机实际使用时用的是补码。

正数的补码就是自己，负数的补码为符号位不变，其余各位按位取反加1。

正数的反码就是自己，负数的反码为符号位不变，其余各位按位取反。
